## 7.4 메소드 재정의
부모 클래스의 모든 메소드가 자식 클래스에게 맞게 설계되어 있다면 가장 이상적인 상속이지만, 어떤 메소드는 자식 클래스가 사용하기에 
적합하지 않을 수 있다. 이러한 메소드는 자식 클래스에서 재정의해서 사용해야 한다. 이것을 **메소드 오버라이딩(Overriding)** 이라고 한다.

### 메소드 오버라이딩
메소드 오버라이딩은 상속된 메소드를 자식 클래스에서 재정의하는 것을 말한다. 메소드가 오버라이딩 되었다면 해당 부모 메소드는 
숨겨지고, 자식 메소드가 우선적으로 사용된다. 

메소드를 오버라이딩 할 때는 다음과 같은 규칙에 주의해서 작성해야 한다.
- 부모 메소드의 선언부 (리턴 타입, 메소드 이름, 매개변수)와 동일해야 한다.
- 접근 제한을 더 강하게 오버라이딩할 수 없다 (public -> private으로 변경 불가)
- 새로운 예외를 throws 할 수 없다.

### @Override
자바는 개발자의 실수를 줄여주기 위해 정확히 오버라이딩 되었는지 체크해주는 @Override 어노테이션을 제공한다.
@Override를 붙이면 컴파일 단계에서 정확히 오버라이딩 되었는지 체크하고, 문제가 있다면 컴파일 에러를 출력한다.


### 부모 메소드 호출
메소드를 재정의하면, 부모 메소드는 숨겨지고 자식 메소드만 사용되기 때문에 비록 부모 메소드의 일부만 변경된다 하더라도
중복된 내용을 자식 메소드도 가지고 있어야 한다. 예를 들어 부모 메소드가 100 줄의 코드를 가지고 있을 경우, 자식 메소드에서 1줄만
추가하고 싶더라도 100줄의 코드를 자식 메소드에서 다시 작성해야 한다.

이 문제는 자식 메소드와 부모 메소드의 **공동 작업 처리 기법**을 이용하면 매우 쉽게 해결된다. **자식 메소드 내에서 부모 메소드를 호출하는 것**인데,
다음과 같이 super 키워드와 도트(.) 연산자를 사용하면 숨겨진 부모 메소드를 호출할 수 있다. 
super.method()의 위치는 작업 처리 전후에 어디든지 올 수 있다. 우선 처리가 되어야 할 내용을 먼저 작성하면 된다. 이 방법은 
부모 메소드를 재사용함으로써 자식 메소드의 중복 작업 내용을 없애는 효과를 가져온다. 

## 7.5 final 클래스와 메소드
### final 클래스 
클래스를 선언할 때 final 키워드를 class 앞에 붙이면 최종적인 클래스이므로 더 이상 상속할 수 없는 클래스가 된다. 즉 final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다.


ex) String final class String { ... }

그래서 다음과 같이 자식 클래스를 만들 수 없다.
public class NewString extends String { ... } (x)